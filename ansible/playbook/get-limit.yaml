---
- name: Modify Sysctl
  hosts: "{{ target_host | default('localhost') }}"
  tasks:
    
    # Limit of socket listen() backlog, known in userspace as SOMAXCONN. Defaults to 128. See also tcp_max_syn_backlog for additional tuning for TCP sockets.
    # https://access.redhat.com/solutions/6439141
    - name: net.core.somaxconn
      block:
      - name: Run CLi
        shell: sysctl -n net.core.somaxconn
        register: somaxconn
      
      - name: net.core.somaxconn
        debug:
          msg: "{{ somaxconn.cmd }} = {{ somaxconn.stdout }} https://access.redhat.com/solutions/6439141"
    
    # Maximal number of remembered connection requests, which have not received an acknowledgment from connecting client. The minimal value is 128 for low memory machines, and it will increase in proportion to the memory of machine. If server suffers from overload, try increasing this number.
    # https://access.redhat.com/solutions/6439141
    - name: net.ipv4.tcp_max_syn_backlog
      block:
      - name: Run CLi
        shell: sysctl -n net.ipv4.tcp_max_syn_backlog
        register: tcp_max_syn_backlog

      - name: net.ipv4.tcp_max_syn_backlog
        debug:
          msg: "{{ tcp_max_syn_backlog.cmd }} = {{ tcp_max_syn_backlog.stdout }}"

    # Maximum number of packets, queued on the INPUT side, when the interface receives packets faster than kernel can process them
    - name: net.core.netdev_max_backlog
      block:
      - name: net.core.netdev_max_backlog
        shell: sysctl -n net.core.netdev_max_backlog
        register: netdev_max_backlog

      - name: net.core.netdev_max_backlog
        debug:
          msg: "{{ netdev_max_backlog.cmd }} = {{ netdev_max_backlog.stdout }}"

    # Only valid when the kernel was compiled with CONFIG_SYN_COOKIES Send out syncookies when the syn backlog queue of a socket overflows. 
    # This is to prevent against the common ‘SYN flood attack’ Default: 1
    # Note, that syncookies is fallback facility. It MUST NOT be used to help highly loaded servers to stand against legal connection rate. 

    # If you see SYN flood warnings in your logs, but investigation shows that they occur because of overload with legal connections, 
    # you should tune another parameters until this warning disappear. See: tcp_max_syn_backlog, tcp_synack_retries, tcp_abort_on_overflow.
    # syncookies seriously violate TCP protocol, do not allow to use TCP extensions, can result in serious degradation of some services (f.e. SMTP relaying), 
    # visible not by you, but your clients and relays, contacting you. While you see SYN flood warnings in logs not being really flooded, 
    # your server is seriously misconfigured.

    # If you want to test which effects syncookies have to your network connections you can set this knob to 2 to enable unconditionally generation of syncookies.
    - name: net.ipv4.tcp_syncookies 
      block:
      - name: net.ipv4.tcp_syncookies 
        shell: sysctl -n net.ipv4.tcp_syncookies 
        register: tcp_syncookies

      - name: net.ipv4.tcp_syncookies 
        debug:
          msg: "{{ tcp_syncookies.cmd }} = {{ tcp_syncookies.stdout }}"


    # Number of times SYNACKs for a passive TCP connection attempt will be retransmitted. 
    # Should not be higher than 255. Default value is 5, which corresponds to 31seconds till the last retransmission with the current initial RTO of 1second. 
    # With this the final timeout for a passive TCP connection will happen after 63seconds
    - name: net.ipv4.tcp_synack_retries
      block:
      - name: net.ipv4.tcp_synack_retries 
        shell: sysctl -n net.ipv4.tcp_synack_retries
        register: tcp_synack_retries

      - name: net.ipv4.tcp_synack_retries
        debug:
          msg: "{{ tcp_synack_retries.cmd }} = {{ tcp_synack_retries.stdout }}"


    # If listening service is too slow to accept new connections, reset them. Default state is FALSE. 
    # It means that if overflow occurred due to a burst, connection will recover. Enable this option only if you are really sure that listening daemon cannot be tuned to accept connections faster. 
    # Enabling this option can harm clients of your server.
    - name: net.ipv4.tcp_abort_on_overflow
      block:
      - name: net.ipv4.tcp_abort_on_overflow
        shell: sysctl -n net.ipv4.tcp_abort_on_overflow
        register: tcp_abort_on_overflow

      - name: net.ipv4.tcp_abort_on_overflow
        debug:
          msg: "{{ tcp_abort_on_overflow.cmd }} = {{ tcp_abort_on_overflow.stdout }}"

    # Allow to reuse TIME-WAIT sockets for new connections when it is safe from protocol viewpoint. 
    # Default value is 0. It should not be changed without advice/request of technical experts.
    - name: net.ipv4.tcp_tw_reuse
      block:
      - name: net.ipv4.tcp_tw_reuse
        shell: sysctl -n net.ipv4.tcp_tw_reuse
        register: tcp_tw_reuse

      - name: net.ipv4.tcp_tw_reuse
        debug:
          msg: "{{ tcp_tw_reuse.cmd }} = {{ tcp_tw_reuse.stdout }}"

    # net.ipv4.tcp_fin_timeout
    - name: net.ipv4.tcp_fin_timeout
      block:
      - name: net.ipv4.tcp_fin_timeout
        shell: sysctl -n net.ipv4.tcp_fin_timeout
        register: tcp_fin_timeout

      - name: net.ipv4.tcp_fin_timeout
        debug:
          msg: "{{ tcp_fin_timeout.cmd }} = {{ tcp_fin_timeout.stdout }}"

    # net.ipv4.tcp_keepalive_time
    - name: net.ipv4.tcp_keepalive_time
      block:
      - name: net.ipv4.tcp_keepalive_time
        shell: sysctl -n net.ipv4.tcp_keepalive_time
        register: tcp_keepalive_time

      - name: net.ipv4.tcp_keepalive_time
        debug:
          msg: "{{ tcp_keepalive_time.cmd }} = {{ tcp_keepalive_time.stdout }}"

    # net.ipv4.tcp_keepalive_intvl
    - name: net.ipv4.tcp_keepalive_intvl
      block:
      - name: net.ipv4.tcp_keepalive_intvl
        shell: sysctl -n net.ipv4.tcp_keepalive_intvl
        register: tcp_keepalive_intvl

      - name: net.ipv4.tcp_keepalive_intvl
        debug:
          msg: "{{ tcp_keepalive_intvl.cmd }} = {{ tcp_keepalive_intvl.stdout }}"

    # net.ipv4.tcp_keepalive_probes
    - name: net.ipv4.tcp_keepalive_probes
      block:
      - name: net.ipv4.tcp_keepalive_probes
        shell: sysctl -n net.ipv4.tcp_keepalive_probes
        register: tcp_keepalive_probes

      - name: net.ipv4.tcp_keepalive_probes
        debug:
          msg: "{{ tcp_keepalive_probes.cmd }} = {{ tcp_keepalive_probes.stdout }}"

    # fs.file-max
    - name: fs.file-max
      block:
      - name: fs.file-max
        shell: sysctl -n fs.file-max
        register: file_max

      - name: fs.file-max
        debug:
          msg: "{{ file_max.cmd }} = {{ file_max.stdout }}"

    # fs.nr_open
    - name: fs.nr_open
      block:
      - name: fs.nr_open
        shell: sysctl -n fs.nr_open
        register: nr_open

      - name: fs.nr_open
        debug:
          msg: "{{ nr_open.cmd }} = {{ nr_open.stdout }}"

    # net.ipv4.tcp_mem
    - name: net.ipv4.tcp_mem
      block:
      - name: net.ipv4.tcp_mem
        shell: sysctl -n net.ipv4.tcp_mem
        register: tcp_mem

      - name: net.ipv4.tcp_mem
        debug:
          msg: "{{ tcp_mem.cmd }} = {{ tcp_mem.stdout }}"

    # net.ipv4.tcp_rmem
    - name: net.ipv4.tcp_rmem
      block:
      - name: net.ipv4.tcp_rmem
        shell: sysctl -n net.ipv4.tcp_rmem
        register: tcp_rmem

      - name: net.ipv4.tcp_rmem
        debug:
          msg: "{{ tcp_rmem.cmd }} = {{ tcp_rmem.stdout }}"